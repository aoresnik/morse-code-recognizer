<!DOCTYPE html>

<!-- Shows an indicator when any key is pressed. Planned as a basis for morse code typing parser. -->

<html>

<head>
    <style media="screen" type="text/css">
    </style>
    <script type="text/javascript">
        // based on https://www.html5canvastutorials.com/advanced/html5-canvas-animation-stage/

        function main() {
            window.requestAnimFrame = (function(callback) {
                return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
                    function(callback) {
                        window.setTimeout(callback, 1000 / 60);
                    };
            })();

            function updateIndicator() {
                if (updateIndicator.prevIndicatorState !== pressState) {
                    context.beginPath();
                    context.ellipse(originX, canvas.height / 2, 50, 50, 0, 0, 2 * Math.PI);;
                    context.fillStyle = pressState ? 'red' : 'black';
                    context.fill();
                    context.lineWidth = 1;
                    updateIndicator.prevIndicatorState = pressState;
                }
            }

            function updateRhythmIndicator() {
                const d = new Date();
                let time = d.getTime();
                /*
                let indicatorState = (time % dotDurationMS) < (0.2 * dotDurationMS);
                if (updateRhythmIndicator.prevIndicatorState !== indicatorState) {
                    context.beginPath();
                    context.ellipse(15, 15, 10, 10, 0, 0, 2 * Math.PI);;
                    context.fillStyle = indicatorState ? 'red' : 'black';
                    context.fill();             
                    updateRhythmIndicator.prevIndicatorState = indicatorState;
                }

                */

                const MARKERS_AHEAD = 5;

                let periodStart = Math.floor(time / dotDurationMS) * dotDurationMS;
                if (periodMarkers.length > 0) { 
                    let nextMarker = periodStart + MARKERS_AHEAD * dotDurationMS;
                    if (periodMarkers[periodMarkers.length - 1] < nextMarker) {
                        periodMarkers.push(nextMarker);
                    }
                } else {
                    for (let i = 0; i < MARKERS_AHEAD; i++) {
                        periodMarkers.push(periodStart + i * dotDurationMS);
                    }
                }

            }

            function addCharacter(character) {
                let resultText = document.getElementById("resultText");
                resultText.value = resultText.value + character;
            }

            function parseWord() {
                console.log("Parsing morse sequence: " + letterBuffer);
                let letter = morseCodeToLetter.get(letterBuffer);
                if (letter !== undefined) {
                    addCharacter(letter);
                } else {
                    console.log("Unknown letter: " + letterBuffer);
                }
                letterBuffer = "";
            }

            function handleDash(dash) {
                let duration = dash.end - dash.start;
                if (dash.pressed) {
                    if (Math.abs(duration - dotDurationMS) < tolerance * dotDurationMS) {
                        letterBuffer = letterBuffer + ".";
                        console.log("Buffer: " + letterBuffer);
                    } else if (Math.abs(duration - 3 * dotDurationMS) < tolerance * 3 * dotDurationMS) {
                        letterBuffer = letterBuffer + "-";
                        console.log("Buffer: " + letterBuffer);
                    } else {
                        console.log("Unknown symbol");
                    }
                } else {
                    // TODO: handle end of word space before the next key is pressed
                    if (Math.abs(duration - dotDurationMS) < tolerance * dotDurationMS) {
                            console.log("(same letter space)");
                        } else if (Math.abs(duration - 3 * dotDurationMS) < tolerance * 3 * dotDurationMS) {
                            console.log("(different letter space)");
                            parseWord();
                        } else if (Math.abs(duration - 5 * dotDurationMS) < tolerance * 5 * dotDurationMS) {
                            console.log("(different word space)");
                            parseWord();
                            addCharacter(' ');
                        } else {
                            console.log("(Unknown space, assuming word space)");
                            parseWord();
                            addCharacter(' ')
                        }
                }
            }

            function keydown(e) {
                e = e || window.event;
                if (!pressState) {
                    // Only if not pressed
                    const t = (new Date()).getTime()

                    // Start playing Morse beep
                    // see https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode
                    // see https://mdn.github.io/webaudio-examples/audio-buffer/
                    soundSource = audioCtx.createBufferSource();
                    soundSource.buffer = beepSoundBuffer;
                    soundSource.connect(audioCtx.destination);
                    soundSource.loop = true;
                    // Continuous tone is between these points in time (between ramp-up and ramp down)
                    soundSource.loopStart = RAMP_UP_TIME_MS/1000.0;
                    soundSource.loopEnd = playSamples/audioCtx.sampleRate-RAMP_UP_TIME_MS/1000.0;

                    // start the source playing
                    soundSource.start();

                    //console.log("Key pressed at " + t);
                    pressState = true;
                    if (dashes.length > 0) {
                        dashes[dashes.length - 1].end = t;
                        handleDash(dashes[dashes.length - 1]);
                    } 
                    dashes.push({
                        pressed: true,
                        start: t,
                        end: null
                    });

                    updateIndicator();
                }
            }

            function keyup(e) {
                e = e || window.event;
                const t = (new Date()).getTime()
                if (soundSource) {
                    // Stop by disabling looping - the sound will end with the ramp down
                    soundSource.loop = false;
                }
                //console.log("Key released at " + t);
                pressState = false;
                updateIndicator();
                dashes[dashes.length - 1].end = t;
                handleDash(dashes[dashes.length - 1]);
                dashes.push({
                        pressed: false,
                        start: t,
                        end: null
                    });
            }

            function animate(canvas, context, startTime) {
                let indicatorY = canvas.height / 2 + 60;
                let indicatorH = 10;
                // TODO: ensure that text is not drawn outside of this boundary
                let textH = 50;

                context.clearRect(0, indicatorY - indicatorH, canvas.width, indicatorH + indicatorH  + textH);

                function barX(t) {
                    return originX - ((new Date()).getTime() - t) / 10;
                }

                updateRhythmIndicator();

                context.fillStyle = 'black';
                context.save();
                context.textAlign = 'right';
                let i = dashes.length - 1;
                while (i >= 0) {
                    const x0 = barX(dashes[i].start);
                    const x1 = dashes[i].end ? barX(dashes[i].end) : originX;
                    if (x1 < 0)
                    {
                        break;
                    }
                    //console.log("Drawing bar from " + x0 + "-" + x1);

                    if (dashes[i].pressed)
                    {
                        context.fillRect(x0, indicatorY, x1 - x0, indicatorH);
                    }
                    if (dashes[i].end)
                    {
                        context.translate((x1+x0)/2, indicatorY+indicatorH+2);
                        context.rotate(-Math.PI / 2);
                        context.fillText((dashes[i].end-dashes[i].start) + " ms", 0, 10 / 2);
                        context.resetTransform();
                    }

                    i--;
                }
                context.restore();

                i = periodMarkers.length - 1;
                while (i >= 0) {
                    const x0 = barX(periodMarkers[i]);
                    if (x0 < 0)
                    {
                        break;
                    }
                    //console.log("Drawing bar from " + x0 + "-" + x1);

                    context.fillRect(x0, indicatorY-indicatorH, 1, 2*indicatorH);

                    i--;
                }


                if (!pressState && (letterBuffer.length > 0)) {
                    //console.log("Key pressed at " + t);
                    const t = (new Date()).getTime()
                    if (t-dashes[dashes.length - 1].start > 3 * dotDurationMS + (tolerance * 3 * dotDurationMS))
                    {
                        console.log("Max inter letter space exceeded, parsing word");
                        parseWord();
                    }
                } 

                // request new frame
                requestAnimFrame(function() {
                    animate(canvas, context, startTime);
                });
            }

            let AudioContext = window.AudioContext || window.webkitAudioContext;
            let audioCtx = new AudioContext({
                latencyHint: 'interactive',
                // Preferred frequency is 44100 Hz (loops calculated for it)
                sampleRate: 44100,
            });
            let channels = 1;

            /**
             * See: https://lcwo.net/forum/1494
             * 641 Hz, but changed, so that integer number of samples (70) represent a
             * period when sample rate is 44100 Hz. This is to reduce pops at the end of tone.
             */
            const FREQ = 630;
            const RAMP_UP_TIME_MS = 2;
            const BUFFER_LEN_MS = 100+2*RAMP_UP_TIME_MS; // High latency, but I was unable to get clear audio with less than 100 ms
            const VOLUME = 0.1;

            const letterToMorseCode  = new Map([
                ["a", ".-"],
                ["b", "-..."],
                ["c", "-.-."],
                ["d", "-.."],
                ["e", "."], 
                ["f", "..-."],
                ["g", "--."],
                ["h", "...."],
                ["i", ".."],
                ["j", ".---"],
                ["k", "-.-"],
                ["l", ".-.."],
                ["m", "--"],
                ["n", "-."],
                ["o", "---"],
                ["p", ".--."],
                ["q", "--.-"],
                ["r", ".-."],
                ["s", "..."],
                ["t", "-"],
                ["u", "..-"],
                ["v", "...-"],
                ["x", "-..-"],
                ["y", "-.--"],
                ["z", "--.."],

                ["1", ".----"],
                ["2", "..---"],
                ["3", "...--"],
                ["4", "....-"],
                ["5", "....."],  
                ["6", "-...."],
                ["7", "--..."],
                ["8", "---.."],
                ["9", "----."],
                ["0", "-----"],
            ]);

            const morseCodeToLetter = new Map();

            for (const key of letterToMorseCode.keys()) {
                morseCodeToLetter.set(letterToMorseCode.get(key), key);
            }

            // Create an empty two second stereo buffer at the
            // sample rate of the AudioContext
            let frameCount = audioCtx.sampleRate * 2.0;

            // Create a buffer with continuous tone, with volume ramp up and down at start and end
            let samplesPerPeriod = audioCtx.sampleRate / (FREQ * 2.0 * Math.PI);
            let playPeriods = (BUFFER_LEN_MS / 1000.0 * audioCtx.sampleRate) / samplesPerPeriod;
            let playSamples = Math.ceil(playPeriods * samplesPerPeriod);
            function ramp_up_envelope(i)
            {
                if (i < (RAMP_UP_TIME_MS/1000.0 * audioCtx.sampleRate))
                {
                    return i/(RAMP_UP_TIME_MS/1000.0 * audioCtx.sampleRate);
                }
                else if (i > (playSamples - (RAMP_UP_TIME_MS/1000.0 * audioCtx.sampleRate)))
                {
                    return (playSamples - i)/(RAMP_UP_TIME_MS/1000.0 * audioCtx.sampleRate);
                }
                else
                {
                    return 1.0;
                }
            }
            let beepSoundBuffer = audioCtx.createBuffer(channels, playSamples, audioCtx.sampleRate);
            for (let channel = 0; channel < channels; channel++) {
                // This gives us the actual array that contains the data
                let nowBuffering = beepSoundBuffer.getChannelData(channel);
                for (let i = 0; i < frameCount; i++) {
                    let angle = i / samplesPerPeriod;
                    nowBuffering[i] = ramp_up_envelope(i) * Math.sin(angle) * VOLUME;
                }
            }

            var canvas = document.getElementById('canvas0');
            var context = canvas.getContext('2d');
            var pressState = false;

            var unitDurationSelect = document.getElementById('unitDuration');
            unitDurationSelect.onchange = function() {
                dotDurationMS = parseInt(unitDurationSelect.value);
            }

            // TODO: limit these to some reasonable number
            var dashes = [];
            var periodMarkers = [];

            var dotDurationMS = 500;
            const tolerance = 0.4;

            var letterBuffer = "";

            document.onkeydown = keydown;
            document.onkeyup = keyup;

            // resize the canvas to fill browser window dynamically
            //window.addEventListener('resize', resizeCanvas, false);

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                originX = canvas.width - 300;
                //canvas.height = window.innerHeight;
            }
            resizeCanvas();
            updateIndicator();

            // wait one second before starting animation
            setTimeout(function() {
                var startTime = (new Date()).getTime();
                animate(canvas, context, startTime);
            }, 1000);
        }
    </script>
</head>

<body onload="main()">
    <label for="resultText">Text:</label>
    <textarea id="resultText" rows="4" cols="50" placeholder="" readonly="true"></textarea>
    <label for="unitDuration">Unit duration:</label>
    <select name="unitDuration" id="unitDuration">
        <option value="100">100ms</option>
        <option value="250">250ms</option>
        <option value="500" selected="true">500ms</option>
        <option value="1000">1000ms</option>
    </select>
    <br>
    <canvas id="canvas0" height="300px"></canvas>
</html>
</body>
